{"sliceID":8912391320880523566,"fragment":[" \nbin :: k -> a -> Map k a -> Map k a -> Map k a","bin k x l r = Bin (size l + size r + 1) k x l r"," \nlink :: k -> a -> Map k a -> Map k a -> Map k a","link kx x Tip r = insertMin kx x r\nlink kx x l Tip = insertMax kx x l\nlink kx x l@(Bin sizeL ky y ly ry) r@(Bin sizeR kz z lz rz)\n  | delta * sizeL < sizeR = balanceL kz z (link kx x l lz) rz\n  | delta * sizeR < sizeL = balanceR ky y ly (link kx x ry r)\n  | otherwise = bin kx x l r"," \nfilterLt :: Ord k => MaybeS k -> Map k v -> Map k v","filterLt NothingS t = t\nfilterLt (JustS b) t = filter' b t\n  where filter' _ Tip = Tip\n        filter' b' (Bin _ kx x l r)\n          = case compare kx b' of\n                LT -> link kx x l (filter' b' r)\n                EQ -> l\n                GT -> filter' b' l"," \nhedgeUnion ::\n             Ord a => MaybeS a -> MaybeS a -> Map a b -> Map a b -> Map a b","hedgeUnion _ _ t1 Tip = t1\nhedgeUnion blo bhi Tip (Bin _ kx x l r)\n  = link kx x (filterGt blo l) (filterLt bhi r)\nhedgeUnion _ _ t1 (Bin _ kx x Tip Tip) = insertR kx x t1\nhedgeUnion blo bhi (Bin _ kx x l r) t2\n  = link kx x (hedgeUnion blo bmi l (trim blo bmi t2))\n      (hedgeUnion bmi bhi r (trim bmi bhi t2))\n  where bmi = JustS kx"," \nunion :: Ord k => Map k a -> Map k a -> Map k a","union Tip t2 = t2\nunion t1 Tip = t1\nunion t1 t2 = hedgeUnion NothingS NothingS t1 t2"," \nunions :: Ord k => [Map k a] -> Map k a","unions ts = foldlStrict union empty ts"," \nfilterGt :: Ord k => MaybeS k -> Map k v -> Map k v","filterGt NothingS t = t\nfilterGt (JustS b) t = filter' b t\n  where filter' _ Tip = Tip\n        filter' b' (Bin _ kx x l r)\n          = case compare b' kx of\n                LT -> link kx x (filter' b' l) r\n                EQ -> r\n                GT -> filter' b' r"," \nfromList :: Ord k => [(k, a)] -> Map k a","fromList [] = Tip\nfromList [(kx, x)] = Bin 1 kx x Tip Tip\nfromList ((kx0, x0) : xs0)\n  | not_ordered kx0 xs0 = fromList' (Bin 1 kx0 x0 Tip Tip) xs0\n  | otherwise = go (1 :: Int) (Bin 1 kx0 x0 Tip Tip) xs0\n  where not_ordered _ [] = False\n        not_ordered kx ((ky, _) : _) = kx >= ky\n         \n        {-# INLINE not_ordered #-}\n        fromList' t0 xs = foldlStrict ins t0 xs\n          where ins t (k, x) = insert k x t\n        go arg _ _ | arg `seq` False = undefined\n        go _ t [] = t\n        go _ t [(kx, x)] = insertMax kx x t\n        go s l xs@((kx, x) : xss)\n          | not_ordered kx xss = fromList' l xs\n          | otherwise =\n            case create s xss of\n                (r, ys, []) -> go (s `shiftL` 1) (link kx x l r) ys\n                (r, _, ys) -> fromList' (link kx x l r) ys\n        create arg _ | arg `seq` False = undefined\n        create _ [] = (Tip, [], [])\n        create s xs@(xp : xss)\n          | s == 1 =\n            case xp of\n                (kx, x) | not_ordered kx xss -> (Bin 1 kx x Tip Tip, [], xss)\n                        | otherwise -> (Bin 1 kx x Tip Tip, xss, [])\n          | otherwise =\n            case create (s `shiftR` 1) xs of\n                res@(_, [], _) -> res\n                (l, [(ky, y)], zs) -> (insertMax ky y l, [], zs)\n                (l, ys@((ky, y) : yss), _) | not_ordered ky yss -> (l, [], ys)\n                                           | otherwise ->\n                                             case create (s `shiftR` 1) yss of\n                                                 (r, zs, ws) -> (link ky y l r, zs, ws)"," \nbalanceR :: k -> a -> Map k a -> Map k a -> Map k a","balanceR k x l r\n  = case l of\n        Tip -> case r of\n                   Tip -> Bin 1 k x Tip Tip\n                   (Bin _ _ _ Tip Tip) -> Bin 2 k x Tip r\n                   (Bin _ rk rx Tip rr@(Bin _ _ _ _ _)) -> Bin 3 rk rx\n                                                             (Bin 1 k x Tip Tip)\n                                                             rr\n                   (Bin _ rk rx (Bin _ rlk rlx _ _) Tip) -> Bin 3 rlk rlx\n                                                              (Bin 1 k x Tip Tip)\n                                                              (Bin 1 rk rx Tip Tip)\n                   (Bin rs rk rx rl@(Bin rls rlk rlx rll rlr)\n                      rr@(Bin rrs _ _ _ _)) | rls < ratio * rrs ->\n                                              Bin (1 + rs) rk rx (Bin (1 + rls) k x Tip rl) rr\n                                            | otherwise ->\n                                              Bin (1 + rs) rlk rlx (Bin (1 + size rll) k x Tip rll)\n                                                (Bin (1 + rrs + size rlr) rk rx rlr rr)\n        (Bin ls _ _ _ _) -> case r of\n                                Tip -> Bin (1 + ls) k x l Tip\n                                (Bin rs rk rx rl rr) | rs > delta * ls ->\n                                                       case (rl, rr) of\n                                                           (Bin rls rlk rlx rll rlr,\n                                                            Bin rrs _ _ _ _) | rls < ratio * rrs ->\n                                                                               Bin (1 + ls + rs) rk\n                                                                                 rx\n                                                                                 (Bin (1 + ls + rls)\n                                                                                    k\n                                                                                    x\n                                                                                    l\n                                                                                    rl)\n                                                                                 rr\n                                                                             | otherwise ->\n                                                                               Bin (1 + ls + rs) rlk\n                                                                                 rlx\n                                                                                 (Bin\n                                                                                    (1 + ls +\n                                                                                       size rll)\n                                                                                    k\n                                                                                    x\n                                                                                    l\n                                                                                    rll)\n                                                                                 (Bin\n                                                                                    (1 + rrs +\n                                                                                       size rlr)\n                                                                                    rk\n                                                                                    rx\n                                                                                    rlr\n                                                                                    rr)\n                                                           (_, _) -> error\n                                                                       \"Failure in Data.Map.balanceR\"\n                                                     | otherwise -> Bin (1 + ls + rs) k x l r"," \ninsertMax, insertMin :: k -> a -> Map k a -> Map k a","insertMax kx x t\n  = case t of\n        Tip -> singleton kx x\n        Bin _ ky y l r -> balanceR ky y l (insertMax kx x r)","insertMin kx x t\n  = case t of\n        Tip -> singleton kx x\n        Bin _ ky y l r -> balanceL ky y (insertMin kx x l) r"," \ninsertR :: Ord k => k -> a -> Map k a -> Map k a","insertR = go\n  where  \n        go :: Ord k => k -> a -> Map k a -> Map k a\n        go arg _ _ | arg `seq` False = undefined\n        go kx x Tip = singleton kx x\n        go kx x t@(Bin _ ky y l r)\n          = case compare kx ky of\n                LT -> balanceL ky y (go kx x l) r\n                GT -> balanceR ky y l (go kx x r)\n                EQ -> t"," \ninsert :: Ord k => k -> a -> Map k a -> Map k a","insert = go\n  where  \n        go :: Ord k => k -> a -> Map k a -> Map k a\n        go arg _ _ | arg `seq` False = undefined\n        go kx x Tip = singleton kx x\n        go kx x (Bin sz ky y l r)\n          = case compare kx ky of\n                LT -> balanceL ky y (go kx x l) r\n                GT -> balanceR ky y l (go kx x r)\n                EQ -> Bin sz kx x l r"," \nbalanceL :: k -> a -> Map k a -> Map k a -> Map k a","balanceL k x l r\n  = case r of\n        Tip -> case l of\n                   Tip -> Bin 1 k x Tip Tip\n                   (Bin _ _ _ Tip Tip) -> Bin 2 k x l Tip\n                   (Bin _ lk lx Tip (Bin _ lrk lrx _ _)) -> Bin 3 lrk lrx\n                                                              (Bin 1 lk lx Tip Tip)\n                                                              (Bin 1 k x Tip Tip)\n                   (Bin _ lk lx ll@(Bin _ _ _ _ _) Tip) -> Bin 3 lk lx ll\n                                                             (Bin 1 k x Tip Tip)\n                   (Bin ls lk lx ll@(Bin lls _ _ _ _)\n                      lr@(Bin lrs lrk lrx lrl lrr)) | lrs < ratio * lls ->\n                                                      Bin (1 + ls) lk lx ll\n                                                        (Bin (1 + lrs) k x lr Tip)\n                                                    | otherwise ->\n                                                      Bin (1 + ls) lrk lrx\n                                                        (Bin (1 + lls + size lrl) lk lx ll lrl)\n                                                        (Bin (1 + size lrr) k x lrr Tip)\n        (Bin rs _ _ _ _) -> case l of\n                                Tip -> Bin (1 + rs) k x Tip r\n                                (Bin ls lk lx ll lr) | ls > delta * rs ->\n                                                       case (ll, lr) of\n                                                           (Bin lls _ _ _ _,\n                                                            Bin lrs lrk lrx lrl lrr) | lrs <\n                                                                                         ratio * lls\n                                                                                       ->\n                                                                                       Bin\n                                                                                         (1 + ls +\n                                                                                            rs)\n                                                                                         lk\n                                                                                         lx\n                                                                                         ll\n                                                                                         (Bin\n                                                                                            (1 + rs\n                                                                                               +\n                                                                                               lrs)\n                                                                                            k\n                                                                                            x\n                                                                                            lr\n                                                                                            r)\n                                                                                     | otherwise ->\n                                                                                       Bin\n                                                                                         (1 + ls +\n                                                                                            rs)\n                                                                                         lrk\n                                                                                         lrx\n                                                                                         (Bin\n                                                                                            (1 + lls\n                                                                                               +\n                                                                                               size\n                                                                                                 lrl)\n                                                                                            lk\n                                                                                            lx\n                                                                                            ll\n                                                                                            lrl)\n                                                                                         (Bin\n                                                                                            (1 + rs\n                                                                                               +\n                                                                                               size\n                                                                                                 lrr)\n                                                                                            k\n                                                                                            x\n                                                                                            lrr\n                                                                                            r)\n                                                           (_, _) -> error\n                                                                       \"Failure in Data.Map.balanceL\"\n                                                     | otherwise -> Bin (1 + ls + rs) k x l r"," \ntrim :: Ord k => MaybeS k -> MaybeS k -> Map k a -> Map k a","trim NothingS NothingS t = t\ntrim (JustS lk) NothingS t = greater lk t\n  where greater lo (Bin _ k _ _ r) | k <= lo = greater lo r\n        greater _ t' = t'\ntrim NothingS (JustS hk) t = lesser hk t\n  where lesser hi (Bin _ k _ l _) | k >= hi = lesser hi l\n        lesser _ t' = t'\ntrim (JustS lk) (JustS hk) t = middle lk hk t\n  where middle lo hi (Bin _ k _ _ r) | k <= lo = middle lo hi r\n        middle lo hi (Bin _ k _ l _) | k >= hi = middle lo hi l\n        middle _ _ t' = t'"," \ntoAscList :: Map k a -> [(k, a)]","toAscList = foldrWithKey (\\ k x xs -> (k, x) : xs) []"," \ntoList :: Map k a -> [(k, a)]","toList = toAscList"," \nfoldrWithKey :: (k -> a -> b -> b) -> b -> Map k a -> b","foldrWithKey f z = go z\n  where go z' Tip = z'\n        go z' (Bin _ kx x l r) = go (f kx x (go z' r)) l"," \nfoldl :: (a -> b -> a) -> a -> Map k b -> a","foldl f z = go z\n  where go z' Tip = z'\n        go z' (Bin _ _ x l r) = go (f (go z' l) x) r"," \nfoldr :: (a -> b -> b) -> b -> Map k a -> b","foldr f z = go z\n  where go z' Tip = z'\n        go z' (Bin _ _ x l r) = go (f x (go z' r)) l"," \ntraverseWithKey ::\n                  Applicative t => (k -> a -> t b) -> Map k a -> t (Map k b)","traverseWithKey f = go\n  where go Tip = pure Tip\n        go (Bin 1 k v _ _) = (\\ v' -> Bin 1 k v' Tip Tip) <$> f k v\n        go (Bin s k v l r) = flip (Bin s k) <$> go l <*> f k v <*> go r"," \nmap :: (a -> b) -> Map k a -> Map k b","map _ Tip = Tip\nmap f (Bin sx kx x l r) = Bin sx kx (f x) (map f l) (map f r)"," \nsingleton :: k -> a -> Map k a","singleton k x = Bin 1 k x Tip Tip"," \nempty :: Map k a","empty = Tip"," \nsize :: Map k a -> Int","size Tip = 0\nsize (Bin sz _ _ _ _) = sz"," \ndata Map k a = Bin {-# UNPACK #-} !Size !k a !(Map k a) !(Map k a)\n             | Tip"," \nderiving instance Typeable Map"," \ninstance (Show k, Show a) => Show (Map k a) where\n        showsPrec d m\n          = showParen (d > 10) $ showString \"fromList \" . shows (toList m)"," \ninstance (Ord k, Read k, Read e) => Read (Map k e) where\n        readPrec\n          = parens $\n              prec 10 $\n                do Ident \"fromList\" <- lexP\n                   xs <- readPrec\n                   return (fromList xs)\n        readListPrec = readListPrecDefault"," \ninstance Foldable.Foldable (Map k) where\n        fold t = go t\n          where go Tip = mempty\n                go (Bin 1 _ v _ _) = v\n                go (Bin _ _ v l r) = go l `mappend` (v `mappend` go r)\n        foldr = foldr\n         \n        {-# INLINE foldr #-}\n        foldl = foldl\n         \n        {-# INLINE foldl #-}\n        foldMap f t = go t\n          where go Tip = mempty\n                go (Bin 1 _ v _ _) = f v\n                go (Bin _ _ v l r) = go l `mappend` (f v `mappend` go r)\n         \n        {-# INLINE foldMap #-}"," \ninstance Traversable (Map k) where\n        traverse f = traverseWithKey (\\ _ -> f)\n         \n        {-# INLINE traverse #-}"," \ninstance Functor (Map k) where\n        fmap f m = map f m"," \ninstance (Ord k, Ord v) => Ord (Map k v) where\n        compare m1 m2 = compare (toAscList m1) (toAscList m2)"," \ninstance (Eq k, Eq a) => Eq (Map k a) where\n        t1 == t2 = (size t1 == size t2) && (toAscList t1 == toAscList t2)"," \ninstance (Ord k) => Monoid (Map k v) where\n        mempty = empty\n        mappend = union\n        mconcat = unions"," \ninstance (Data k, Data a, Ord k) => Data (Map k a) where\n        gfoldl f z m = z fromList `f` toList m\n        toConstr _ = fromListConstr\n        gunfold k z c\n          = case constrIndex c of\n                1 -> k (z fromList)\n                _ -> error \"gunfold\"\n        dataTypeOf _ = mapDataType\n        dataCast2 f = gcast2 f"],"usages":[{"reference":{"otherSlice":673578264655578396},"usedName":{"typeIdentifier":"Size"},"qualification":null},{"reference":{"originalModule":"Data.Typeable.Internal"},"usedName":{"typeIdentifier":"Typeable"},"qualification":null},{"reference":{"originalModule":"Text.Show"},"usedName":{"typeIdentifier":"Show"},"qualification":null},{"reference":{"originalModule":"Text.Show"},"usedName":{"valueIdentifier":"showsPrec"},"qualification":null},{"reference":{"originalModule":"Text.Show"},"usedName":{"valueIdentifier":"showParen"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":">"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":"$"},"qualification":null},{"reference":{"originalModule":"Text.Show"},"usedName":{"valueIdentifier":"showString"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":"."},"qualification":null},{"reference":{"originalModule":"Text.Show"},"usedName":{"valueIdentifier":"shows"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"typeIdentifier":"Ord"},"qualification":null},{"reference":{"originalModule":"Text.Read"},"usedName":{"typeIdentifier":"Read"},"qualification":null},{"reference":{"originalModule":"Text.Read"},"usedName":{"valueIdentifier":"readPrec"},"qualification":null},{"reference":{"originalModule":"Text.Read"},"usedName":{"valueIdentifier":"parens"},"qualification":null},{"reference":{"originalModule":"Text.Read"},"usedName":{"valueIdentifier":"prec"},"qualification":null},{"reference":{"originalModule":"Text.Read.Lex"},"usedName":{"typeName":"Lexeme","constructorIdentifier":"Ident"},"qualification":null},{"reference":{"originalModule":"Text.Read"},"usedName":{"valueIdentifier":"lexP"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueIdentifier":"return"},"qualification":null},{"reference":{"originalModule":"Text.Read"},"usedName":{"valueIdentifier":"readListPrec"},"qualification":null},{"reference":{"originalModule":"Text.Read"},"usedName":{"valueIdentifier":"readListPrecDefault"},"qualification":null},{"reference":{"originalModule":"Data.Foldable"},"usedName":{"typeIdentifier":"Foldable"},"qualification":"Foldable"},{"reference":{"originalModule":"Data.Foldable"},"usedName":{"valueIdentifier":"fold"},"qualification":"Foldable"},{"reference":{"originalModule":"Data.Monoid"},"usedName":{"valueIdentifier":"mempty"},"qualification":null},{"reference":{"originalModule":"Data.Monoid"},"usedName":{"valueIdentifier":"mappend"},"qualification":null},{"reference":{"originalModule":"Data.Foldable"},"usedName":{"valueIdentifier":"foldr"},"qualification":"Foldable"},{"reference":{"originalModule":"Data.Foldable"},"usedName":{"valueIdentifier":"foldl"},"qualification":"Foldable"},{"reference":{"originalModule":"Data.Foldable"},"usedName":{"valueIdentifier":"foldMap"},"qualification":"Foldable"},{"reference":{"originalModule":"Data.Traversable"},"usedName":{"typeIdentifier":"Traversable"},"qualification":null},{"reference":{"originalModule":"Data.Traversable"},"usedName":{"valueIdentifier":"traverse"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"typeIdentifier":"Functor"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueIdentifier":"fmap"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueIdentifier":"compare"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"typeIdentifier":"Eq"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":"=="},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":"&&"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":"+"},"qualification":null},{"reference":{"otherSlice":1747553165193419273},"usedName":{"valueIdentifier":"delta"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":"*"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":"<"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueIdentifier":"otherwise"},"qualification":null},{"reference":{"otherSlice":2621329941938049112},"usedName":{"typeName":"MaybeS","constructorIdentifier":"NothingS"},"qualification":null},{"reference":{"otherSlice":2621329941938049112},"usedName":{"typeName":"MaybeS","constructorIdentifier":"JustS"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"typeName":"Ordering","constructorIdentifier":"LT"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"typeName":"Ordering","constructorIdentifier":"EQ"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"typeName":"Ordering","constructorIdentifier":"GT"},"qualification":null},{"reference":{"otherSlice":2621329941938049112},"usedName":{"typeIdentifier":"MaybeS"},"qualification":null},{"reference":{"otherSlice":1553206181863891259},"usedName":{"valueIdentifier":"foldlStrict"},"qualification":null},{"reference":{"originalModule":"Data.Monoid"},"usedName":{"typeIdentifier":"Monoid"},"qualification":null},{"reference":{"originalModule":"Data.Monoid"},"usedName":{"valueIdentifier":"mconcat"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"typeIdentifier":"Int"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"typeName":"Bool","constructorIdentifier":"False"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":">="},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueIdentifier":"seq"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueIdentifier":"undefined"},"qualification":null},{"reference":{"originalModule":"Foreign.Safe"},"usedName":{"valueIdentifier":"shiftL"},"qualification":null},{"reference":{"originalModule":"Foreign.Safe"},"usedName":{"valueIdentifier":"shiftR"},"qualification":null},{"reference":{"originalModule":"Data.Data"},"usedName":{"typeIdentifier":"Data"},"qualification":null},{"reference":{"originalModule":"Data.Data"},"usedName":{"valueIdentifier":"gfoldl"},"qualification":null},{"reference":{"originalModule":"Data.Data"},"usedName":{"valueIdentifier":"toConstr"},"qualification":null},{"reference":{"otherSlice":7723890927583089886},"usedName":{"valueIdentifier":"fromListConstr"},"qualification":null},{"reference":{"originalModule":"Data.Data"},"usedName":{"valueIdentifier":"gunfold"},"qualification":null},{"reference":{"originalModule":"Data.Data"},"usedName":{"valueIdentifier":"constrIndex"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueIdentifier":"error"},"qualification":null},{"reference":{"originalModule":"Data.Data"},"usedName":{"valueIdentifier":"dataTypeOf"},"qualification":null},{"reference":{"otherSlice":7723890927583089886},"usedName":{"valueIdentifier":"mapDataType"},"qualification":null},{"reference":{"originalModule":"Data.Data"},"usedName":{"valueIdentifier":"dataCast2"},"qualification":null},{"reference":{"originalModule":"Data.Typeable"},"usedName":{"valueIdentifier":"gcast2"},"qualification":null},{"reference":{"otherSlice":1747553165193419273},"usedName":{"valueIdentifier":"ratio"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":"<="},"qualification":null},{"reference":{"originalModule":"Control.Applicative"},"usedName":{"valueIdentifier":"pure"},"qualification":null},{"reference":{"originalModule":"Data.Functor"},"usedName":{"valueOperator":"<$>"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueIdentifier":"flip"},"qualification":null},{"reference":{"originalModule":"Control.Applicative"},"usedName":{"valueOperator":"<*>"},"qualification":null},{"reference":{"originalModule":"Control.Applicative"},"usedName":{"typeIdentifier":"Applicative"},"qualification":null}],"language":["DeriveDataTypeable","StandaloneDeriving","Trustworthy"]}