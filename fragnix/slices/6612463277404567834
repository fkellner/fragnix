{"sliceID":6612463277404567834,"fragment":[" \ndeleteFindMax :: Set a -> (a, Set a)","deleteFindMax t\n  = case t of\n        Bin _ x l Tip -> (x, l)\n        Bin _ x l r -> let (xm, r') = deleteFindMax r in\n                         (xm, balanceL x l r')\n        Tip -> (error\n                  \"Set.deleteFindMax: can not return the maximal element of an empty set\",\n                Tip)"],"usages":[{"reference":{"otherSlice":186780576224115314},"usedName":{"typeName":"Set","constructorIdentifier":"Bin"},"qualification":null},{"reference":{"otherSlice":186780576224115314},"usedName":{"typeName":"Set","constructorIdentifier":"Tip"},"qualification":null},{"reference":{"otherSlice":186780576224115314},"usedName":{"valueIdentifier":"balanceL"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueIdentifier":"error"},"qualification":null},{"reference":{"otherSlice":186780576224115314},"usedName":{"typeIdentifier":"Set"},"qualification":null}],"language":["DeriveDataTypeable","StandaloneDeriving","Trustworthy"]}