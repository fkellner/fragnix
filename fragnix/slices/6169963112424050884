{"sliceID":6169963112424050884,"fragment":[" \nlink :: Prefix -> IntMap a -> Prefix -> IntMap a -> IntMap a","link p1 t1 p2 t2\n  | zero p1 m = Bin p m t1 t2\n  | otherwise = Bin p m t2 t1\n  where m = branchMask p1 p2\n        p = mask p1 m"," \nmergeWithKey' ::\n              (Prefix -> Mask -> IntMap c -> IntMap c -> IntMap c) ->\n                (IntMap a -> IntMap b -> IntMap c) ->\n                  (IntMap a -> IntMap c) ->\n                    (IntMap b -> IntMap c) -> IntMap a -> IntMap b -> IntMap c","mergeWithKey' bin' f g1 g2 = go\n  where go t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)\n          | shorter m1 m2 = merge1\n          | shorter m2 m1 = merge2\n          | p1 == p2 = bin' p1 m1 (go l1 l2) (go r1 r2)\n          | otherwise = maybe_link p1 (g1 t1) p2 (g2 t2)\n          where merge1\n                  | nomatch p2 p1 m1 = maybe_link p1 (g1 t1) p2 (g2 t2)\n                  | zero p2 m1 = bin' p1 m1 (go l1 t2) (g1 r1)\n                  | otherwise = bin' p1 m1 (g1 l1) (go r1 t2)\n                merge2\n                  | nomatch p1 p2 m2 = maybe_link p1 (g1 t1) p2 (g2 t2)\n                  | zero p1 m2 = bin' p2 m2 (go t1 l2) (g2 r2)\n                  | otherwise = bin' p2 m2 (g2 l2) (go t1 r2)\n        go t1'@(Bin _ _ _ _) t2'@(Tip k2' _) = merge t2' k2' t1'\n          where merge t2 k2 t1@(Bin p1 m1 l1 r1)\n                  | nomatch k2 p1 m1 = maybe_link p1 (g1 t1) k2 (g2 t2)\n                  | zero k2 m1 = bin' p1 m1 (merge t2 k2 l1) (g1 r1)\n                  | otherwise = bin' p1 m1 (g1 l1) (merge t2 k2 r1)\n                merge t2 k2 t1@(Tip k1 _)\n                  | k1 == k2 = f t1 t2\n                  | otherwise = maybe_link k1 (g1 t1) k2 (g2 t2)\n                merge t2 _ Nil = g2 t2\n        go t1@(Bin _ _ _ _) Nil = g1 t1\n        go t1'@(Tip k1' _) t2' = merge t1' k1' t2'\n          where merge t1 k1 t2@(Bin p2 m2 l2 r2)\n                  | nomatch k1 p2 m2 = maybe_link k1 (g1 t1) p2 (g2 t2)\n                  | zero k1 m2 = bin' p2 m2 (merge t1 k1 l2) (g2 r2)\n                  | otherwise = bin' p2 m2 (g2 l2) (merge t1 k1 r2)\n                merge t1 k1 t2@(Tip k2 _)\n                  | k1 == k2 = f t1 t2\n                  | otherwise = maybe_link k1 (g1 t1) k2 (g2 t2)\n                merge t1 _ Nil = g1 t1\n        go Nil t2 = g2 t2\n        maybe_link _ Nil _ t2 = t2\n        maybe_link _ t1 _ Nil = t1\n        maybe_link p1 t1 p2 t2 = link p1 t1 p2 t2\n         \n        {-# INLINE maybe_link #-}"," \nunion :: IntMap a -> IntMap a -> IntMap a","union m1 m2 = mergeWithKey' Bin const id id m1 m2"," \nunions :: [IntMap a] -> IntMap a","unions xs = foldlStrict union empty xs"," \nfromList :: [(Key, a)] -> IntMap a","fromList xs = foldlStrict ins empty xs\n  where ins t (k, x) = insert k x t"," \ninsert :: Key -> a -> IntMap a -> IntMap a","insert k x t\n  = k `seq`\n      case t of\n          Bin p m l r | nomatch k p m -> link k (Tip k x) p t\n                      | zero k m -> Bin p m (insert k x l) r\n                      | otherwise -> Bin p m l (insert k x r)\n          Tip ky _ | k == ky -> Tip k x\n                   | otherwise -> link k (Tip k x) ky t\n          Nil -> Tip k x"," \nnequal :: Eq a => IntMap a -> IntMap a -> Bool","nequal (Bin p1 m1 l1 r1) (Bin p2 m2 l2 r2)\n  = (m1 /= m2) || (p1 /= p2) || (nequal l1 l2) || (nequal r1 r2)\nnequal (Tip kx x) (Tip ky y) = (kx /= ky) || (x /= y)\nnequal Nil Nil = False\nnequal _ _ = True"," \nequal :: Eq a => IntMap a -> IntMap a -> Bool","equal (Bin p1 m1 l1 r1) (Bin p2 m2 l2 r2)\n  = (m1 == m2) && (p1 == p2) && (equal l1 l2) && (equal r1 r2)\nequal (Tip kx x) (Tip ky y) = (kx == ky) && (x == y)\nequal Nil Nil = True\nequal _ _ = False"," \ntoAscList :: IntMap a -> [(Key, a)]","toAscList = foldrWithKey (\\ k x xs -> (k, x) : xs) []"," \ntoList :: IntMap a -> [(Key, a)]","toList = toAscList"," \nfoldrWithKey :: (Key -> a -> b -> b) -> b -> IntMap a -> b","foldrWithKey f z\n  = \\ t ->\n      case t of\n          Bin _ m l r | m < 0 -> go (go z l) r\n                      | otherwise -> go (go z r) l\n          _ -> go z t\n  where go z' Nil = z'\n        go z' (Tip kx x) = f kx x z'\n        go z' (Bin _ _ l r) = go (go z' r) l"," \nfoldl :: (a -> b -> a) -> a -> IntMap b -> a","foldl f z\n  = \\ t ->\n      case t of\n          Bin _ m l r | m < 0 -> go (go z r) l\n                      | otherwise -> go (go z l) r\n          _ -> go z t\n  where go z' Nil = z'\n        go z' (Tip _ x) = f z' x\n        go z' (Bin _ _ l r) = go (go z' l) r"," \nfoldr :: (a -> b -> b) -> b -> IntMap a -> b","foldr f z\n  = \\ t ->\n      case t of\n          Bin _ m l r | m < 0 -> go (go z l) r\n                      | otherwise -> go (go z r) l\n          _ -> go z t\n  where go z' Nil = z'\n        go z' (Tip _ x) = f x z'\n        go z' (Bin _ _ l r) = go (go z' r) l"," \ntraverseWithKey ::\n                  Applicative t => (Key -> a -> t b) -> IntMap a -> t (IntMap b)","traverseWithKey f = go\n  where go Nil = pure Nil\n        go (Tip k v) = Tip k <$> f k v\n        go (Bin p m l r) = Bin p m <$> go l <*> go r"," \nmap :: (a -> b) -> IntMap a -> IntMap b","map f t\n  = case t of\n        Bin p m l r -> Bin p m (map f l) (map f r)\n        Tip k x -> Tip k (f x)\n        Nil -> Nil"," \nempty :: IntMap a","empty = Nil"," \ndata IntMap a = Bin {-# UNPACK #-} !Prefix {-# UNPACK #-} !Mask\n                    !(IntMap a) !(IntMap a)\n              | Tip {-# UNPACK #-} !Key a\n              | Nil"," \ninstance Monoid (IntMap a) where\n        mempty = empty\n        mappend = union\n        mconcat = unions"," \ninstance (Read e) => Read (IntMap e) where\n        readPrec\n          = parens $\n              prec 10 $\n                do Ident \"fromList\" <- lexP\n                   xs <- readPrec\n                   return (fromList xs)\n        readListPrec = readListPrecDefault"," \ninstance Data a => Data (IntMap a) where\n        gfoldl f z im = z fromList `f` (toList im)\n        toConstr _ = fromListConstr\n        gunfold k z c\n          = case constrIndex c of\n                1 -> k (z fromList)\n                _ -> error \"gunfold\"\n        dataTypeOf _ = intMapDataType\n        dataCast1 f = gcast1 f"," \nderiving instance Typeable IntMap"," \ninstance Show a => Show (IntMap a) where\n        showsPrec d m\n          = showParen (d > 10) $ showString \"fromList \" . shows (toList m)"," \ninstance Functor IntMap where\n        fmap = map"," \ninstance Ord a => Ord (IntMap a) where\n        compare m1 m2 = compare (toList m1) (toList m2)"," \ninstance Eq a => Eq (IntMap a) where\n        t1 == t2 = equal t1 t2\n        t1 /= t2 = nequal t1 t2"," \ninstance Foldable.Foldable IntMap where\n        fold t = go t\n          where go Nil = mempty\n                go (Tip _ v) = v\n                go (Bin _ _ l r) = go l `mappend` go r\n        foldr = foldr\n         \n        {-# INLINE foldr #-}\n        foldl = foldl\n         \n        {-# INLINE foldl #-}\n        foldMap f t = go t\n          where go Nil = mempty\n                go (Tip _ v) = f v\n                go (Bin _ _ l r) = go l `mappend` go r\n         \n        {-# INLINE foldMap #-}"," \ninstance Traversable IntMap where\n        traverse f = traverseWithKey (\\ _ -> f)\n         \n        {-# INLINE traverse #-}"],"usages":[{"reference":{"otherSlice":6579781088168822167},"usedName":{"typeIdentifier":"Prefix"},"qualification":null},{"reference":{"otherSlice":8410168028702583491},"usedName":{"typeIdentifier":"Mask"},"qualification":null},{"reference":{"otherSlice":6676978071093904330},"usedName":{"typeIdentifier":"Key"},"qualification":null},{"reference":{"otherSlice":8074001225160819453},"usedName":{"valueIdentifier":"zero"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueIdentifier":"otherwise"},"qualification":null},{"reference":{"otherSlice":3732964581313987065},"usedName":{"valueIdentifier":"branchMask"},"qualification":null},{"reference":{"otherSlice":5742591193739304890},"usedName":{"valueIdentifier":"mask"},"qualification":null},{"reference":{"otherSlice":7968970582648128070},"usedName":{"valueIdentifier":"shorter"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":"=="},"qualification":null},{"reference":{"otherSlice":6817481598170301897},"usedName":{"valueIdentifier":"nomatch"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueIdentifier":"const"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueIdentifier":"id"},"qualification":null},{"reference":{"otherSlice":1553206181863891259},"usedName":{"valueIdentifier":"foldlStrict"},"qualification":null},{"reference":{"originalModule":"Data.Monoid"},"usedName":{"typeIdentifier":"Monoid"},"qualification":null},{"reference":{"originalModule":"Data.Monoid"},"usedName":{"valueIdentifier":"mempty"},"qualification":null},{"reference":{"originalModule":"Data.Monoid"},"usedName":{"valueIdentifier":"mappend"},"qualification":null},{"reference":{"originalModule":"Data.Monoid"},"usedName":{"valueIdentifier":"mconcat"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueIdentifier":"seq"},"qualification":null},{"reference":{"originalModule":"Text.Read"},"usedName":{"typeIdentifier":"Read"},"qualification":null},{"reference":{"originalModule":"Text.Read"},"usedName":{"valueIdentifier":"readPrec"},"qualification":null},{"reference":{"originalModule":"Text.Read"},"usedName":{"valueIdentifier":"parens"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":"$"},"qualification":null},{"reference":{"originalModule":"Text.Read"},"usedName":{"valueIdentifier":"prec"},"qualification":null},{"reference":{"originalModule":"Text.Read.Lex"},"usedName":{"typeName":"Lexeme","constructorIdentifier":"Ident"},"qualification":null},{"reference":{"originalModule":"Text.Read"},"usedName":{"valueIdentifier":"lexP"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueIdentifier":"return"},"qualification":null},{"reference":{"originalModule":"Text.Read"},"usedName":{"valueIdentifier":"readListPrec"},"qualification":null},{"reference":{"originalModule":"Text.Read"},"usedName":{"valueIdentifier":"readListPrecDefault"},"qualification":null},{"reference":{"originalModule":"Data.Data"},"usedName":{"typeIdentifier":"Data"},"qualification":null},{"reference":{"originalModule":"Data.Data"},"usedName":{"valueIdentifier":"gfoldl"},"qualification":null},{"reference":{"originalModule":"Data.Data"},"usedName":{"valueIdentifier":"toConstr"},"qualification":null},{"reference":{"otherSlice":1318553232112945631},"usedName":{"valueIdentifier":"fromListConstr"},"qualification":null},{"reference":{"originalModule":"Data.Data"},"usedName":{"valueIdentifier":"gunfold"},"qualification":null},{"reference":{"originalModule":"Data.Data"},"usedName":{"valueIdentifier":"constrIndex"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueIdentifier":"error"},"qualification":null},{"reference":{"originalModule":"Data.Data"},"usedName":{"valueIdentifier":"dataTypeOf"},"qualification":null},{"reference":{"otherSlice":1318553232112945631},"usedName":{"valueIdentifier":"intMapDataType"},"qualification":null},{"reference":{"originalModule":"Data.Data"},"usedName":{"valueIdentifier":"dataCast1"},"qualification":null},{"reference":{"originalModule":"Data.Typeable"},"usedName":{"valueIdentifier":"gcast1"},"qualification":null},{"reference":{"originalModule":"Data.Typeable.Internal"},"usedName":{"typeIdentifier":"Typeable"},"qualification":null},{"reference":{"originalModule":"Text.Show"},"usedName":{"typeIdentifier":"Show"},"qualification":null},{"reference":{"originalModule":"Text.Show"},"usedName":{"valueIdentifier":"showsPrec"},"qualification":null},{"reference":{"originalModule":"Text.Show"},"usedName":{"valueIdentifier":"showParen"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":">"},"qualification":null},{"reference":{"originalModule":"Text.Show"},"usedName":{"valueIdentifier":"showString"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":"."},"qualification":null},{"reference":{"originalModule":"Text.Show"},"usedName":{"valueIdentifier":"shows"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"typeIdentifier":"Functor"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueIdentifier":"fmap"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"typeIdentifier":"Ord"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueIdentifier":"compare"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":"/="},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":"||"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"typeName":"Bool","constructorIdentifier":"False"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"typeName":"Bool","constructorIdentifier":"True"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"typeIdentifier":"Eq"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"typeIdentifier":"Bool"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":"&&"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":"<"},"qualification":null},{"reference":{"originalModule":"Data.Foldable"},"usedName":{"typeIdentifier":"Foldable"},"qualification":"Foldable"},{"reference":{"originalModule":"Data.Foldable"},"usedName":{"valueIdentifier":"fold"},"qualification":"Foldable"},{"reference":{"originalModule":"Data.Foldable"},"usedName":{"valueIdentifier":"foldr"},"qualification":"Foldable"},{"reference":{"originalModule":"Data.Foldable"},"usedName":{"valueIdentifier":"foldl"},"qualification":"Foldable"},{"reference":{"originalModule":"Data.Foldable"},"usedName":{"valueIdentifier":"foldMap"},"qualification":"Foldable"},{"reference":{"originalModule":"Control.Applicative"},"usedName":{"valueIdentifier":"pure"},"qualification":null},{"reference":{"originalModule":"Data.Functor"},"usedName":{"valueOperator":"<$>"},"qualification":null},{"reference":{"originalModule":"Control.Applicative"},"usedName":{"valueOperator":"<*>"},"qualification":null},{"reference":{"originalModule":"Control.Applicative"},"usedName":{"typeIdentifier":"Applicative"},"qualification":null},{"reference":{"originalModule":"Data.Traversable"},"usedName":{"typeIdentifier":"Traversable"},"qualification":null},{"reference":{"originalModule":"Data.Traversable"},"usedName":{"valueIdentifier":"traverse"},"qualification":null}],"language":["MagicHash","DeriveDataTypeable","StandaloneDeriving","Trustworthy"]}