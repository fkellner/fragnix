{"sliceID":355792201696823248,"fragment":[" \ndeleteFindMin :: Set a -> (a, Set a)","deleteFindMin t\n  = case t of\n        Bin _ x Tip r -> (x, r)\n        Bin _ x l r -> let (xm, l') = deleteFindMin l in\n                         (xm, balanceR x l' r)\n        Tip -> (error\n                  \"Set.deleteFindMin: can not return the minimal element of an empty set\",\n                Tip)"],"usages":[{"reference":{"otherSlice":186780576224115314},"usedName":{"typeName":"Set","constructorIdentifier":"Bin"},"qualification":null},{"reference":{"otherSlice":186780576224115314},"usedName":{"typeName":"Set","constructorIdentifier":"Tip"},"qualification":null},{"reference":{"otherSlice":186780576224115314},"usedName":{"valueIdentifier":"balanceR"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueIdentifier":"error"},"qualification":null},{"reference":{"otherSlice":186780576224115314},"usedName":{"typeIdentifier":"Set"},"qualification":null}],"language":["DeriveDataTypeable","StandaloneDeriving","Trustworthy"]}