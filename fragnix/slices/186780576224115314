{"sliceID":186780576224115314,"fragment":[" \nbin :: a -> Set a -> Set a -> Set a","bin x l r = Bin (size l + size r + 1) x l r"," \nlink :: a -> Set a -> Set a -> Set a","link x Tip r = insertMin x r\nlink x l Tip = insertMax x l\nlink x l@(Bin sizeL y ly ry) r@(Bin sizeR z lz rz)\n  | delta * sizeL < sizeR = balanceL z (link x l lz) rz\n  | delta * sizeR < sizeL = balanceR y ly (link x ry r)\n  | otherwise = bin x l r"," \nfilterLt :: Ord a => MaybeS a -> Set a -> Set a","filterLt NothingS t = t\nfilterLt (JustS b) t = filter' b t\n  where filter' _ Tip = Tip\n        filter' b' (Bin _ x l r)\n          = case compare x b' of\n                LT -> link x l (filter' b' r)\n                EQ -> l\n                GT -> filter' b' l"," \nhedgeUnion ::\n             Ord a => MaybeS a -> MaybeS a -> Set a -> Set a -> Set a","hedgeUnion _ _ t1 Tip = t1\nhedgeUnion blo bhi Tip (Bin _ x l r)\n  = link x (filterGt blo l) (filterLt bhi r)\nhedgeUnion _ _ t1 (Bin _ x Tip Tip) = insertR x t1\nhedgeUnion blo bhi (Bin _ x l r) t2\n  = link x (hedgeUnion blo bmi l (trim blo bmi t2))\n      (hedgeUnion bmi bhi r (trim bmi bhi t2))\n  where bmi = JustS x"," \nunion :: Ord a => Set a -> Set a -> Set a","union Tip t2 = t2\nunion t1 Tip = t1\nunion t1 t2 = hedgeUnion NothingS NothingS t1 t2"," \nunions :: Ord a => [Set a] -> Set a","unions = foldlStrict union empty"," \nfilterGt :: Ord a => MaybeS a -> Set a -> Set a","filterGt NothingS t = t\nfilterGt (JustS b) t = filter' b t\n  where filter' _ Tip = Tip\n        filter' b' (Bin _ x l r)\n          = case compare b' x of\n                LT -> link x (filter' b' l) r\n                EQ -> r\n                GT -> filter' b' r"," \nfromList :: Ord a => [a] -> Set a","fromList [] = Tip\nfromList [x] = Bin 1 x Tip Tip\nfromList (x0 : xs0)\n  | not_ordered x0 xs0 = fromList' (Bin 1 x0 Tip Tip) xs0\n  | otherwise = go (1 :: Int) (Bin 1 x0 Tip Tip) xs0\n  where not_ordered _ [] = False\n        not_ordered x (y : _) = x >= y\n         \n        {-# INLINE not_ordered #-}\n        fromList' t0 xs = foldlStrict ins t0 xs\n          where ins t x = insert x t\n        go arg _ _ | arg `seq` False = undefined\n        go _ t [] = t\n        go _ t [x] = insertMax x t\n        go s l xs@(x : xss)\n          | not_ordered x xss = fromList' l xs\n          | otherwise =\n            case create s xss of\n                (r, ys, []) -> go (s `shiftL` 1) (link x l r) ys\n                (r, _, ys) -> fromList' (link x l r) ys\n        create arg _ | arg `seq` False = undefined\n        create _ [] = (Tip, [], [])\n        create s xs@(x : xss)\n          | s == 1 =\n            if not_ordered x xss then (Bin 1 x Tip Tip, [], xss) else\n              (Bin 1 x Tip Tip, xss, [])\n          | otherwise =\n            case create (s `shiftR` 1) xs of\n                res@(_, [], _) -> res\n                (l, [y], zs) -> (insertMax y l, [], zs)\n                (l, ys@(y : yss), _) | not_ordered y yss -> (l, [], ys)\n                                     | otherwise ->\n                                       case create (s `shiftR` 1) yss of\n                                           (r, zs, ws) -> (link y l r, zs, ws)"," \nbalanceR :: a -> Set a -> Set a -> Set a","balanceR x l r\n  = case l of\n        Tip -> case r of\n                   Tip -> Bin 1 x Tip Tip\n                   (Bin _ _ Tip Tip) -> Bin 2 x Tip r\n                   (Bin _ rx Tip rr@(Bin _ _ _ _)) -> Bin 3 rx (Bin 1 x Tip Tip) rr\n                   (Bin _ rx (Bin _ rlx _ _) Tip) -> Bin 3 rlx (Bin 1 x Tip Tip)\n                                                       (Bin 1 rx Tip Tip)\n                   (Bin rs rx rl@(Bin rls rlx rll rlr) rr@(Bin rrs _ _ _)) | rls <\n                                                                               ratio * rrs\n                                                                             ->\n                                                                             Bin (1 + rs) rx\n                                                                               (Bin (1 + rls) x Tip\n                                                                                  rl)\n                                                                               rr\n                                                                           | otherwise ->\n                                                                             Bin (1 + rs) rlx\n                                                                               (Bin (1 + size rll) x\n                                                                                  Tip\n                                                                                  rll)\n                                                                               (Bin\n                                                                                  (1 + rrs +\n                                                                                     size rlr)\n                                                                                  rx\n                                                                                  rlr\n                                                                                  rr)\n        (Bin ls _ _ _) -> case r of\n                              Tip -> Bin (1 + ls) x l Tip\n                              (Bin rs rx rl rr) | rs > delta * ls ->\n                                                  case (rl, rr) of\n                                                      (Bin rls rlx rll rlr, Bin rrs _ _ _) | rls <\n                                                                                               ratio\n                                                                                                 *\n                                                                                                 rrs\n                                                                                             ->\n                                                                                             Bin\n                                                                                               (1 +\n                                                                                                  ls\n                                                                                                  +\n                                                                                                  rs)\n                                                                                               rx\n                                                                                               (Bin\n                                                                                                  (1 +\n                                                                                                     ls\n                                                                                                     +\n                                                                                                     rls)\n                                                                                                  x\n                                                                                                  l\n                                                                                                  rl)\n                                                                                               rr\n                                                                                           | otherwise\n                                                                                             ->\n                                                                                             Bin\n                                                                                               (1 +\n                                                                                                  ls\n                                                                                                  +\n                                                                                                  rs)\n                                                                                               rlx\n                                                                                               (Bin\n                                                                                                  (1 +\n                                                                                                     ls\n                                                                                                     +\n                                                                                                     size\n                                                                                                       rll)\n                                                                                                  x\n                                                                                                  l\n                                                                                                  rll)\n                                                                                               (Bin\n                                                                                                  (1 +\n                                                                                                     rrs\n                                                                                                     +\n                                                                                                     size\n                                                                                                       rlr)\n                                                                                                  rx\n                                                                                                  rlr\n                                                                                                  rr)\n                                                      (_, _) -> error \"Failure in Data.Map.balanceR\"\n                                                | otherwise -> Bin (1 + ls + rs) x l r"," \ninsertMax, insertMin :: a -> Set a -> Set a","insertMax x t\n  = case t of\n        Tip -> singleton x\n        Bin _ y l r -> balanceR y l (insertMax x r)","insertMin x t\n  = case t of\n        Tip -> singleton x\n        Bin _ y l r -> balanceL y (insertMin x l) r"," \ninsertR :: Ord a => a -> Set a -> Set a","insertR = go\n  where  \n        go :: Ord a => a -> Set a -> Set a\n        go arg _ | arg `seq` False = undefined\n        go x Tip = singleton x\n        go x t@(Bin _ y l r)\n          = case compare x y of\n                LT -> balanceL y (go x l) r\n                GT -> balanceR y l (go x r)\n                EQ -> t"," \ninsert :: Ord a => a -> Set a -> Set a","insert = go\n  where  \n        go :: Ord a => a -> Set a -> Set a\n        go arg _ | arg `seq` False = undefined\n        go x Tip = singleton x\n        go x (Bin sz y l r)\n          = case compare x y of\n                LT -> balanceL y (go x l) r\n                GT -> balanceR y l (go x r)\n                EQ -> Bin sz x l r"," \nbalanceL :: a -> Set a -> Set a -> Set a","balanceL x l r\n  = case r of\n        Tip -> case l of\n                   Tip -> Bin 1 x Tip Tip\n                   (Bin _ _ Tip Tip) -> Bin 2 x l Tip\n                   (Bin _ lx Tip (Bin _ lrx _ _)) -> Bin 3 lrx (Bin 1 lx Tip Tip)\n                                                       (Bin 1 x Tip Tip)\n                   (Bin _ lx ll@(Bin _ _ _ _) Tip) -> Bin 3 lx ll (Bin 1 x Tip Tip)\n                   (Bin ls lx ll@(Bin lls _ _ _) lr@(Bin lrs lrx lrl lrr)) | lrs <\n                                                                               ratio * lls\n                                                                             ->\n                                                                             Bin (1 + ls) lx ll\n                                                                               (Bin (1 + lrs) x lr\n                                                                                  Tip)\n                                                                           | otherwise ->\n                                                                             Bin (1 + ls) lrx\n                                                                               (Bin\n                                                                                  (1 + lls +\n                                                                                     size lrl)\n                                                                                  lx\n                                                                                  ll\n                                                                                  lrl)\n                                                                               (Bin (1 + size lrr) x\n                                                                                  lrr\n                                                                                  Tip)\n        (Bin rs _ _ _) -> case l of\n                              Tip -> Bin (1 + rs) x Tip r\n                              (Bin ls lx ll lr) | ls > delta * rs ->\n                                                  case (ll, lr) of\n                                                      (Bin lls _ _ _, Bin lrs lrx lrl lrr) | lrs <\n                                                                                               ratio\n                                                                                                 *\n                                                                                                 lls\n                                                                                             ->\n                                                                                             Bin\n                                                                                               (1 +\n                                                                                                  ls\n                                                                                                  +\n                                                                                                  rs)\n                                                                                               lx\n                                                                                               ll\n                                                                                               (Bin\n                                                                                                  (1 +\n                                                                                                     rs\n                                                                                                     +\n                                                                                                     lrs)\n                                                                                                  x\n                                                                                                  lr\n                                                                                                  r)\n                                                                                           | otherwise\n                                                                                             ->\n                                                                                             Bin\n                                                                                               (1 +\n                                                                                                  ls\n                                                                                                  +\n                                                                                                  rs)\n                                                                                               lrx\n                                                                                               (Bin\n                                                                                                  (1 +\n                                                                                                     lls\n                                                                                                     +\n                                                                                                     size\n                                                                                                       lrl)\n                                                                                                  lx\n                                                                                                  ll\n                                                                                                  lrl)\n                                                                                               (Bin\n                                                                                                  (1 +\n                                                                                                     rs\n                                                                                                     +\n                                                                                                     size\n                                                                                                       lrr)\n                                                                                                  x\n                                                                                                  lrr\n                                                                                                  r)\n                                                      (_, _) -> error \"Failure in Data.Map.balanceL\"\n                                                | otherwise -> Bin (1 + ls + rs) x l r"," \ntrim :: Ord a => MaybeS a -> MaybeS a -> Set a -> Set a","trim NothingS NothingS t = t\ntrim (JustS lx) NothingS t = greater lx t\n  where greater lo (Bin _ x _ r) | x <= lo = greater lo r\n        greater _ t' = t'\ntrim NothingS (JustS hx) t = lesser hx t\n  where lesser hi (Bin _ x l _) | x >= hi = lesser hi l\n        lesser _ t' = t'\ntrim (JustS lx) (JustS hx) t = middle lx hx t\n  where middle lo hi (Bin _ x _ r) | x <= lo = middle lo hi r\n        middle lo hi (Bin _ x l _) | x >= hi = middle lo hi l\n        middle _ _ t' = t'"," \ntoAscList :: Set a -> [a]","toAscList = foldr (:) []"," \ntoList :: Set a -> [a]","toList = toAscList"," \nfoldl :: (a -> b -> a) -> a -> Set b -> a","foldl f z = go z\n  where go z' Tip = z'\n        go z' (Bin _ x l r) = go (f (go z' l) x) r"," \nfoldr :: (a -> b -> b) -> b -> Set a -> b","foldr f z = go z\n  where go z' Tip = z'\n        go z' (Bin _ x l r) = go (f x (go z' r)) l"," \nsingleton :: a -> Set a","singleton x = Bin 1 x Tip Tip"," \nempty :: Set a","empty = Tip"," \nsize :: Set a -> Int","size Tip = 0\nsize (Bin sz _ _ _) = sz"," \ndata Set a = Bin {-# UNPACK #-} !Size !a !(Set a) !(Set a)\n           | Tip"," \ninstance Ord a => Monoid (Set a) where\n        mempty = empty\n        mappend = union\n        mconcat = unions"," \ninstance (Read a, Ord a) => Read (Set a) where\n        readPrec\n          = parens $\n              prec 10 $\n                do Ident \"fromList\" <- lexP\n                   xs <- readPrec\n                   return (fromList xs)\n        readListPrec = readListPrecDefault"," \ninstance (Data a, Ord a) => Data (Set a) where\n        gfoldl f z set = z fromList `f` (toList set)\n        toConstr _ = fromListConstr\n        gunfold k z c\n          = case constrIndex c of\n                1 -> k (z fromList)\n                _ -> error \"gunfold\"\n        dataTypeOf _ = setDataType\n        dataCast1 f = gcast1 f"," \nderiving instance Typeable Set"," \ninstance Show a => Show (Set a) where\n        showsPrec p xs\n          = showParen (p > 10) $ showString \"fromList \" . shows (toList xs)"," \ninstance Ord a => Ord (Set a) where\n        compare s1 s2 = compare (toAscList s1) (toAscList s2)"," \ninstance Eq a => Eq (Set a) where\n        t1 == t2 = (size t1 == size t2) && (toAscList t1 == toAscList t2)"," \ninstance Foldable.Foldable Set where\n        fold t = go t\n          where go Tip = mempty\n                go (Bin 1 k _ _) = k\n                go (Bin _ k l r) = go l `mappend` (k `mappend` go r)\n        foldr = foldr\n         \n        {-# INLINE foldr #-}\n        foldl = foldl\n         \n        {-# INLINE foldl #-}\n        foldMap f t = go t\n          where go Tip = mempty\n                go (Bin 1 k _ _) = f k\n                go (Bin _ k l r) = go l `mappend` (f k `mappend` go r)\n         \n        {-# INLINE foldMap #-}"],"usages":[{"reference":{"otherSlice":673578264655578396},"usedName":{"typeIdentifier":"Size"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":"+"},"qualification":null},{"reference":{"otherSlice":1747553165193419273},"usedName":{"valueIdentifier":"delta"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":"*"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":"<"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueIdentifier":"otherwise"},"qualification":null},{"reference":{"otherSlice":2621329941938049112},"usedName":{"typeName":"MaybeS","constructorIdentifier":"NothingS"},"qualification":null},{"reference":{"otherSlice":2621329941938049112},"usedName":{"typeName":"MaybeS","constructorIdentifier":"JustS"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueIdentifier":"compare"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"typeName":"Ordering","constructorIdentifier":"LT"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"typeName":"Ordering","constructorIdentifier":"EQ"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"typeName":"Ordering","constructorIdentifier":"GT"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"typeIdentifier":"Ord"},"qualification":null},{"reference":{"otherSlice":2621329941938049112},"usedName":{"typeIdentifier":"MaybeS"},"qualification":null},{"reference":{"otherSlice":1553206181863891259},"usedName":{"valueIdentifier":"foldlStrict"},"qualification":null},{"reference":{"originalModule":"Data.Monoid"},"usedName":{"typeIdentifier":"Monoid"},"qualification":null},{"reference":{"originalModule":"Data.Monoid"},"usedName":{"valueIdentifier":"mempty"},"qualification":null},{"reference":{"originalModule":"Data.Monoid"},"usedName":{"valueIdentifier":"mappend"},"qualification":null},{"reference":{"originalModule":"Data.Monoid"},"usedName":{"valueIdentifier":"mconcat"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"typeIdentifier":"Int"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"typeName":"Bool","constructorIdentifier":"False"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":">="},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueIdentifier":"seq"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueIdentifier":"undefined"},"qualification":null},{"reference":{"originalModule":"Foreign.Safe"},"usedName":{"valueIdentifier":"shiftL"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":"=="},"qualification":null},{"reference":{"originalModule":"Foreign.Safe"},"usedName":{"valueIdentifier":"shiftR"},"qualification":null},{"reference":{"originalModule":"Text.Read"},"usedName":{"typeIdentifier":"Read"},"qualification":null},{"reference":{"originalModule":"Text.Read"},"usedName":{"valueIdentifier":"readPrec"},"qualification":null},{"reference":{"originalModule":"Text.Read"},"usedName":{"valueIdentifier":"parens"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":"$"},"qualification":null},{"reference":{"originalModule":"Text.Read"},"usedName":{"valueIdentifier":"prec"},"qualification":null},{"reference":{"originalModule":"Text.Read.Lex"},"usedName":{"typeName":"Lexeme","constructorIdentifier":"Ident"},"qualification":null},{"reference":{"originalModule":"Text.Read"},"usedName":{"valueIdentifier":"lexP"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueIdentifier":"return"},"qualification":null},{"reference":{"originalModule":"Text.Read"},"usedName":{"valueIdentifier":"readListPrec"},"qualification":null},{"reference":{"originalModule":"Text.Read"},"usedName":{"valueIdentifier":"readListPrecDefault"},"qualification":null},{"reference":{"originalModule":"Data.Data"},"usedName":{"typeIdentifier":"Data"},"qualification":null},{"reference":{"originalModule":"Data.Data"},"usedName":{"valueIdentifier":"gfoldl"},"qualification":null},{"reference":{"originalModule":"Data.Data"},"usedName":{"valueIdentifier":"toConstr"},"qualification":null},{"reference":{"otherSlice":2186142305057455356},"usedName":{"valueIdentifier":"fromListConstr"},"qualification":null},{"reference":{"originalModule":"Data.Data"},"usedName":{"valueIdentifier":"gunfold"},"qualification":null},{"reference":{"originalModule":"Data.Data"},"usedName":{"valueIdentifier":"constrIndex"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueIdentifier":"error"},"qualification":null},{"reference":{"originalModule":"Data.Data"},"usedName":{"valueIdentifier":"dataTypeOf"},"qualification":null},{"reference":{"otherSlice":2186142305057455356},"usedName":{"valueIdentifier":"setDataType"},"qualification":null},{"reference":{"originalModule":"Data.Data"},"usedName":{"valueIdentifier":"dataCast1"},"qualification":null},{"reference":{"originalModule":"Data.Typeable"},"usedName":{"valueIdentifier":"gcast1"},"qualification":null},{"reference":{"otherSlice":1747553165193419273},"usedName":{"valueIdentifier":"ratio"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":">"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":"<="},"qualification":null},{"reference":{"originalModule":"Data.Typeable.Internal"},"usedName":{"typeIdentifier":"Typeable"},"qualification":null},{"reference":{"originalModule":"Text.Show"},"usedName":{"typeIdentifier":"Show"},"qualification":null},{"reference":{"originalModule":"Text.Show"},"usedName":{"valueIdentifier":"showsPrec"},"qualification":null},{"reference":{"originalModule":"Text.Show"},"usedName":{"valueIdentifier":"showParen"},"qualification":null},{"reference":{"originalModule":"Text.Show"},"usedName":{"valueIdentifier":"showString"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":"."},"qualification":null},{"reference":{"originalModule":"Text.Show"},"usedName":{"valueIdentifier":"shows"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"typeIdentifier":"Eq"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":"&&"},"qualification":null},{"reference":{"originalModule":"Data.Foldable"},"usedName":{"typeIdentifier":"Foldable"},"qualification":"Foldable"},{"reference":{"originalModule":"Data.Foldable"},"usedName":{"valueIdentifier":"fold"},"qualification":"Foldable"},{"reference":{"originalModule":"Data.Foldable"},"usedName":{"valueIdentifier":"foldr"},"qualification":"Foldable"},{"reference":{"originalModule":"Data.Foldable"},"usedName":{"valueIdentifier":"foldl"},"qualification":"Foldable"},{"reference":{"originalModule":"Data.Foldable"},"usedName":{"valueIdentifier":"foldMap"},"qualification":"Foldable"}],"language":["DeriveDataTypeable","StandaloneDeriving","Trustworthy"]}