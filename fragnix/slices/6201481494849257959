{"sliceID":6201481494849257959,"fragment":[" \nlink :: Prefix -> IntSet -> Prefix -> IntSet -> IntSet","link p1 t1 p2 t2\n  | zero p1 m = Bin p m t1 t2\n  | otherwise = Bin p m t2 t1\n  where m = branchMask p1 p2\n        p = mask p1 m"," \nunion :: IntSet -> IntSet -> IntSet","union t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)\n  | shorter m1 m2 = union1\n  | shorter m2 m1 = union2\n  | p1 == p2 = Bin p1 m1 (union l1 l2) (union r1 r2)\n  | otherwise = link p1 t1 p2 t2\n  where union1\n          | nomatch p2 p1 m1 = link p1 t1 p2 t2\n          | zero p2 m1 = Bin p1 m1 (union l1 t2) r1\n          | otherwise = Bin p1 m1 l1 (union r1 t2)\n        union2\n          | nomatch p1 p2 m2 = link p1 t1 p2 t2\n          | zero p1 m2 = Bin p2 m2 (union t1 l2) r2\n          | otherwise = Bin p2 m2 l2 (union t1 r2)\nunion t@(Bin _ _ _ _) (Tip kx bm) = insertBM kx bm t\nunion t@(Bin _ _ _ _) Nil = t\nunion (Tip kx bm) t = insertBM kx bm t\nunion Nil t = t"," \nunions :: [IntSet] -> IntSet","unions xs = foldlStrict union empty xs"," \ninsertBM :: Prefix -> BitMap -> IntSet -> IntSet","insertBM kx bm t\n  = kx `seq`\n      bm `seq`\n        case t of\n            Bin p m l r | nomatch kx p m -> link kx (Tip kx bm) p t\n                        | zero kx m -> Bin p m (insertBM kx bm l) r\n                        | otherwise -> Bin p m l (insertBM kx bm r)\n            Tip kx' bm' | kx' == kx -> Tip kx' (bm .|. bm')\n                        | otherwise -> link kx (Tip kx bm) kx' t\n            Nil -> Tip kx bm"," \nfromList :: [Key] -> IntSet","fromList xs = foldlStrict ins empty xs\n  where ins t x = insert x t"," \ninsert :: Key -> IntSet -> IntSet","insert x = x `seq` insertBM (prefixOf x) (bitmapOf x)"," \nnequal :: IntSet -> IntSet -> Bool","nequal (Bin p1 m1 l1 r1) (Bin p2 m2 l2 r2)\n  = (m1 /= m2) || (p1 /= p2) || (nequal l1 l2) || (nequal r1 r2)\nnequal (Tip kx1 bm1) (Tip kx2 bm2) = kx1 /= kx2 || bm1 /= bm2\nnequal Nil Nil = False\nnequal _ _ = True"," \nequal :: IntSet -> IntSet -> Bool","equal (Bin p1 m1 l1 r1) (Bin p2 m2 l2 r2)\n  = (m1 == m2) && (p1 == p2) && (equal l1 l2) && (equal r1 r2)\nequal (Tip kx1 bm1) (Tip kx2 bm2) = kx1 == kx2 && bm1 == bm2\nequal Nil Nil = True\nequal _ _ = False"," \ntoAscList :: IntSet -> [Key]","toAscList = foldr (:) []"," \ntoList :: IntSet -> [Key]","toList = toAscList"," \nfoldr :: (Key -> b -> b) -> b -> IntSet -> b","foldr f z\n  = \\ t ->\n      case t of\n          Bin _ m l r | m < 0 -> go (go z l) r\n                      | otherwise -> go (go z r) l\n          _ -> go z t\n  where go z' Nil = z'\n        go z' (Tip kx bm) = foldrBits kx f z' bm\n        go z' (Bin _ _ l r) = go (go z' r) l"," \nempty :: IntSet","empty = Nil"," \ndata IntSet = Bin {-# UNPACK #-} !Prefix {-# UNPACK #-} !Mask\n                  !IntSet !IntSet\n            | Tip {-# UNPACK #-} !Prefix {-# UNPACK #-} !BitMap\n            | Nil"," \ninstance Monoid IntSet where\n        mempty = empty\n        mappend = union\n        mconcat = unions"," \ninstance Read IntSet where\n        readPrec\n          = parens $\n              prec 10 $\n                do Ident \"fromList\" <- lexP\n                   xs <- readPrec\n                   return (fromList xs)\n        readListPrec = readListPrecDefault"," \ninstance Data IntSet where\n        gfoldl f z is = z fromList `f` (toList is)\n        toConstr _ = fromListConstr\n        gunfold k z c\n          = case constrIndex c of\n                1 -> k (z fromList)\n                _ -> error \"gunfold\"\n        dataTypeOf _ = intSetDataType"," \nderiving instance Typeable IntSet"," \ninstance Show IntSet where\n        showsPrec p xs\n          = showParen (p > 10) $ showString \"fromList \" . shows (toList xs)"," \ninstance Ord IntSet where\n        compare s1 s2 = compare (toAscList s1) (toAscList s2)"," \ninstance Eq IntSet where\n        t1 == t2 = equal t1 t2\n        t1 /= t2 = nequal t1 t2"],"usages":[{"reference":{"otherSlice":6579781088168822167},"usedName":{"typeIdentifier":"Prefix"},"qualification":null},{"reference":{"otherSlice":8410168028702583491},"usedName":{"typeIdentifier":"Mask"},"qualification":null},{"reference":{"otherSlice":1818098628608137155},"usedName":{"typeIdentifier":"BitMap"},"qualification":null},{"reference":{"otherSlice":8252304037800035275},"usedName":{"valueIdentifier":"zero"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueIdentifier":"otherwise"},"qualification":null},{"reference":{"otherSlice":7891636737794698799},"usedName":{"valueIdentifier":"branchMask"},"qualification":null},{"reference":{"otherSlice":1592244927340524014},"usedName":{"valueIdentifier":"mask"},"qualification":null},{"reference":{"otherSlice":7855493408048578582},"usedName":{"valueIdentifier":"shorter"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":"=="},"qualification":null},{"reference":{"otherSlice":7037959029960672173},"usedName":{"valueIdentifier":"nomatch"},"qualification":null},{"reference":{"otherSlice":1553206181863891259},"usedName":{"valueIdentifier":"foldlStrict"},"qualification":null},{"reference":{"originalModule":"Data.Monoid"},"usedName":{"typeIdentifier":"Monoid"},"qualification":null},{"reference":{"originalModule":"Data.Monoid"},"usedName":{"valueIdentifier":"mempty"},"qualification":null},{"reference":{"originalModule":"Data.Monoid"},"usedName":{"valueIdentifier":"mappend"},"qualification":null},{"reference":{"originalModule":"Data.Monoid"},"usedName":{"valueIdentifier":"mconcat"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueIdentifier":"seq"},"qualification":null},{"reference":{"originalModule":"Foreign.Safe"},"usedName":{"valueOperator":".|."},"qualification":null},{"reference":{"otherSlice":4000244827084555474},"usedName":{"valueIdentifier":"prefixOf"},"qualification":null},{"reference":{"otherSlice":4756139699404414776},"usedName":{"valueIdentifier":"bitmapOf"},"qualification":null},{"reference":{"originalModule":"Text.Read"},"usedName":{"typeIdentifier":"Read"},"qualification":null},{"reference":{"originalModule":"Text.Read"},"usedName":{"valueIdentifier":"readPrec"},"qualification":null},{"reference":{"originalModule":"Text.Read"},"usedName":{"valueIdentifier":"parens"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":"$"},"qualification":null},{"reference":{"originalModule":"Text.Read"},"usedName":{"valueIdentifier":"prec"},"qualification":null},{"reference":{"originalModule":"Text.Read.Lex"},"usedName":{"typeName":"Lexeme","constructorIdentifier":"Ident"},"qualification":null},{"reference":{"originalModule":"Text.Read"},"usedName":{"valueIdentifier":"lexP"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueIdentifier":"return"},"qualification":null},{"reference":{"originalModule":"Text.Read"},"usedName":{"valueIdentifier":"readListPrec"},"qualification":null},{"reference":{"originalModule":"Text.Read"},"usedName":{"valueIdentifier":"readListPrecDefault"},"qualification":null},{"reference":{"otherSlice":6676978071093904330},"usedName":{"typeIdentifier":"Key"},"qualification":null},{"reference":{"originalModule":"Data.Data"},"usedName":{"typeIdentifier":"Data"},"qualification":null},{"reference":{"originalModule":"Data.Data"},"usedName":{"valueIdentifier":"gfoldl"},"qualification":null},{"reference":{"originalModule":"Data.Data"},"usedName":{"valueIdentifier":"toConstr"},"qualification":null},{"reference":{"otherSlice":2307108848367926031},"usedName":{"valueIdentifier":"fromListConstr"},"qualification":null},{"reference":{"originalModule":"Data.Data"},"usedName":{"valueIdentifier":"gunfold"},"qualification":null},{"reference":{"originalModule":"Data.Data"},"usedName":{"valueIdentifier":"constrIndex"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueIdentifier":"error"},"qualification":null},{"reference":{"originalModule":"Data.Data"},"usedName":{"valueIdentifier":"dataTypeOf"},"qualification":null},{"reference":{"otherSlice":2307108848367926031},"usedName":{"valueIdentifier":"intSetDataType"},"qualification":null},{"reference":{"originalModule":"Data.Typeable.Internal"},"usedName":{"typeIdentifier":"Typeable"},"qualification":null},{"reference":{"originalModule":"Text.Show"},"usedName":{"typeIdentifier":"Show"},"qualification":null},{"reference":{"originalModule":"Text.Show"},"usedName":{"valueIdentifier":"showsPrec"},"qualification":null},{"reference":{"originalModule":"Text.Show"},"usedName":{"valueIdentifier":"showParen"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":">"},"qualification":null},{"reference":{"originalModule":"Text.Show"},"usedName":{"valueIdentifier":"showString"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":"."},"qualification":null},{"reference":{"originalModule":"Text.Show"},"usedName":{"valueIdentifier":"shows"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"typeIdentifier":"Ord"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueIdentifier":"compare"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":"/="},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":"||"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"typeName":"Bool","constructorIdentifier":"False"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"typeName":"Bool","constructorIdentifier":"True"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"typeIdentifier":"Bool"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"typeIdentifier":"Eq"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":"&&"},"qualification":null},{"reference":{"originalModule":"Prelude"},"usedName":{"valueOperator":"<"},"qualification":null},{"reference":{"otherSlice":3700153713451306769},"usedName":{"valueIdentifier":"foldrBits"},"qualification":null}],"language":["MagicHash","BangPatterns","DeriveDataTypeable","StandaloneDeriving","Trustworthy"]}